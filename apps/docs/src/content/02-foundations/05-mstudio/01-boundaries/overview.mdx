<Alert>
  <Heading>Guideline für interne Teams</Heading>
  <Content>
    Diese Guideline richtet sich in erster Linie an das interne Team von
    mittwald und setzt entsprechendes Vorwissen voraus. Die darin genannten
    Komponenten beziehen sich auf interne mStudio-Komponenten.
  </Content>
</Alert>

# Technische Umsetzung

Bei der Platzierung der Boundaries empfiehlt es sich, vom Groben ins Detail
vorzugehen. Entscheidend ist eine gute Balance: Zu viele kleine Boundaries
erhöhen die Komplexität, zu wenige gefährden hingegen die Stabilität großer
Teile der Anwendung.

| Typ                  | Verwendung                                                     | Element     | Fehlerfall                        | Loading                                            |
| -------------------- | -------------------------------------------------------------- | ----------- | --------------------------------- | -------------------------------------------------- |
| `LayoutCard`         | Äußerste Boundary einer Seite                                  | LayoutCard  | LayoutCard mit IllustratedMessage | LayoutCard mit Sections mit mehrzeiligen Skeletons |
| `LayoutCardFragment` | Für Dashboards mit ungewisser Anzahl und Breite der Kacheln    | Fragment    | LayoutCard mit IllustratedMessage | LayoutCard mit Sections mit mehrzeiligen Skeletons |
| `SectionsFragment`   | Äußerste Boundary in Tabs                                      | Fragment    | IllustratedMessage                | Sections mit mehrzeiligen Skeletons                |
| `Section`            | Ersetzt normale Sections                                       | Section     | Fehler Section                    | Mehrzeilige Skeletons                              |
| `ContentFragment`    | Für mehrzeilige Inhalte                                        | Fragment    | Mehrzeilige Skeletons             | Mehrzeilige Skeletons                              |
| `Fragment`           | Für Inhalte die im Lade / Fehlerzustand nicht angezeigt werden | Fragment    | Nichts                            | Nichts                                             |
| `ContextMenu`        | Ersetzt normale ContextMenus                                   | ContextMenu | Menu Items mit Skeleton           | Menu Item mit Fehlertext                           |
| `Modal`              | Ersetzt normale Modals                                         | Modal       | IllustratedMessage                | LoadingView der Flow Component                     |
| `Text`               | Für Texte                                                      | Text        | Fehlertext                        | Einzeiliges Skeleton                               |
| `String`             | Für einzeilige Inhalte                                         | Fragment    | Fehlertext                        | Einzeiliges Skeleton                               |
| `Link`               | Für Links                                                      | Link        | Fehlertext                        | Einzeiliges Skeleton                               |
| `Avatar`             | Für Avatare                                                    | Avatar      | Leerer Avatar                     | Avatar Skeleton                                    |
| `FieldFragment`      | Für Form Fields mit nachgeladenen Inhalten                     | Fragment    | Nichts                            | Text Field                                         |

## Inhalte einer LayoutCard (WithBoundaries.LayoutCard)

Sind Funktionen oder Informationen einer LayoutCard essenziell für die Nutzung
der Seite, sollte die gesamte LayoutCard mit `WithBoundaries.LayoutCard`
umschlossen sein.

[Beispiel LayoutCard]

## Inhalte eines Tabs (WithBoundaries.SectionsFragment)

Manchmal sind Inhalte einer Seite auf mehrere Tabs verteilt, sodass es sich
lohnen kann einen Tab seperat zu schützen. Nutze dafür
`WithBoundaries.SectionsFragment` und gebe eine Anzahl der geladenen Sections
als SectionsCount mit um entsprechende LoadingView zu steuern. Wird in dem Tab
eine Liste geladen, sollte sie mit dem SectionsCount 1 geladen werden.

### Listenseite

- `WithBoundaries.LayoutCard` mit sectionsCount 1

- Count der Liste wird direkt hier geladen, damit im Fehlerfall die ganze Seite
  eine Fehlermeldung zeigt (Liste ist Hauptelement der Seite)

```
export const CronjobsPage: FC = () => (
  <WithBoundaries.LayoutCard suspenseFallbackProps={{ sectionsCount: 1 }}>
    {() => {
      const { projectId } = usePathParams("projectId");
      const projectGhost = ProjectGhost.ofId(projectId);
      const cronjobCount = projectGhost.cronjobs.getTotalCount().use();

      return (
        <>
          <ProjectDeactivatedAlert project={projectGhost} />
          <WithBoundaries.Section>
            {backupCount === 0 ? <CronjobIllustratedMessage project={projectGhost} /> : <CronjobList project={projectGhost} />}
          </WithBoundaries.Section>
        </>
      );
    }}
  </WithBoundaries.LayoutCard>
);
```

### Detailseite / Tab

- `WithBoundaries.LayoutCard` / `WithBoundaries.SectionsFragment` mit
  SectionCount, je nach Anzahl der auf jeden Fall geladenen Sections

- Cronjob wird als Hauptelement der Seite hier geladen, damit im Fehlerfall die
  ganze Seite eine Fehlermeldung zeigt

```
export const CronjobPage: FC = () => (
  <WithBoundaries.LayoutCard suspenseFallbackProps={{ sectionsCount: 3 }}>
    {() => {
      const { cronjobId } = usePathParams("cronjobId");
      const cronjob = CronjobGhost.ofId(cronjobId).getCommon().use();

      return (
        <>
          <ProjectDeactivatedAlert project={cronjob.project} />
          <GeneralSection cronjob={cronjob} />
          <IntervalSection cronjob={cronjob} />
        </>
      );
    }}
  </WithBoundaries.LayoutCard>
);
```

```
export const CronjobTabs: FC = () => (
  <LayoutCard>
    <Tabs>
      <Tab>
        <TabTitle>Allgemein</TabTitle>
        <WithBoundaries.SectionsFragment suspenseFallbackProps={{ sectionsCount: 3 }}>
          {() => {
            const { cronjobId } = usePathParams("cronjobId");
            const cronjob = CronjobGhost.ofId(cronjobId).getCommon().use();

            return (
              <>
                <ProjectDeactivatedAlert project={cronjob.project} />
                <GeneralSection cronjob={cronjob} />
                <IntervalSection cronjob={cronjob} />
              </>
            );
          }}
        </WithBoundaries.SectionsFragment>
      </Tab>
    </Tabs>
  </LayoutCard>
);
```

## Inhalte von Forms in Modals (WithBoundaries.Modal)

Eine teilweise geladene oder fehlerhafte Form untergräbt das Vertrauen der User
und kann zu unvollständigen oder inkonsistenten Daten führen. Daher sollte eine
Form immer mithilfe von `WithBoundaries.Modal` geschützt werden. Sobald
innerhalb der Form ein Fehler aufftritt, fällt das automatisch das ganze Modal
in eine Error-View, auch wenn es darin noch Boundaries gibt.

```
interface Props {
  cronjob:CronjobProxy;
  controller?: OverlayController;
}

export const RenameCronjobModal: FC<Props> = (props) => (
  <WithBoundaries.Modal controller={props.controller}>
    {() => {
      const { cronjobProxy } = asProxyProps(props, ["cronjob"]);
      const controller = useOverlayController("Modal");
      const form = useForm();
      const handleOnSubmit = async () => {
        ...
        controller.close();
      };

      return (
        <Form form={form} onSubmit={handleOnSubmit}>
          ...
        </Form>
      );
    }}
  </WithBoundaries.Modal>
);
```

## Inhalte einzelner Sections (WithBoundaries.Section)

Eine Section kann ergänzende Informationen oder Funktionen aus einem anderen
Service enthalten, die das primäre Nutzererlebnis der Seite nicht einschränken.
In solchen Fällen lohnt sich eine Abgrenzung über `WithBoundaries.Section`. So
bleiben Fehler auf einen kleinen Bereich beschränkt, ohne die gesamte Seite zu
gefährden.

```
export const GeneralSection: FC<Props> = (props) => (
  <WithBoundaries.Section>
    {() => {
      const { cronjobGhost } = asGhostProps(props);
      const cronjob = cronjobGhost.getCommon().use();
      const t = useTCronjob();

      return (
        <>
          <Heading>{t("cronjob")}</Heading>
          ...
        </>
      );
    }}
  </WithBoundaries.Section>
);
```

**Sonderfall:** Manche Sections werden nur unter bestimmten Bedingungen
angezeigt. In diesen Situationen soll keine eigene Loading-View erzeugt werden,
damit Nutzer kein Ladeverhalten sehen, das später nicht zu einem sichtbaren
Ergebnis führt. Für solche Fälle eignet sich `WithBoundaries.Fragment`, da es
die Section schützt, ohne einen sichtbaren Ladezustand zu erzeugen.

```
export const AppInstallationSection: FC<Props> = (props) => (
  <WithBoundaries.Fragment>
    {() => {
      const { cronjobGhost } = asGhostProps(props);
      const cronjob = cronjobGhost.getCommon().use();
      const t = useTCronjob();

      if(!cronjob.linkedAppInstallation){
        return null;
      }

      return (
        <Section>...</Section>
      );
    }}
  </WithBoundaries.Fragment>
);
```

## Inhalte eines Diagramms (WIP)

Diagramme beziehen in der Regel viele Daten aus externen Service und sind daher
fehleranfällig. Sie sollten immer separat von einer Boundary umschlossen werden.
Diagramm-Komponenten wie das `CartesianChart` besitzen eine eigene Error-View.
Ist das nicht der Fall, sollte mindestens die Section des Diagramms mit einer
Boundary abgesichert werden.

[Code-Beispiele??]

## Inhalte einzelner kleinerer Elemente

Kleine Ergänzungen wie Texte, Links, ContextMenus, Badges oder Actions werden
oft dynamisch geladen. Diese sollten ebenfalls seperat geschützt werden, um
nicht die gesamte Seite zu blockieren. Da diese Elemente keine eigene Error-View
besitzen, erscheinen sie im Fehlerfall nicht oder verbleiben im Ladezustand.

### Texte

```
<LabeledValue>
  <Label>{t("projectShortId")}</Label>
  <WithBoundaries.Text>
    {() =>  projectGhost.getCommon().use().shortId }
  </WithBoundaries.Text>
</LabeledValue>
```

Zusätzlich gibt es Components die direkt auf ein Model angewendet werden können
und eine eingebaute Boundary besitzen.

```
<ModelLink model={cronjob}>
  <ModelTitle model={cronjob} />
</ModelLink>

<ModelLabeledValue model={cronjob}/>
```

### ContextMenu

```
export const ActionsContextMenu: FC<Props> = (props) => {
  const { cronjobProxy } = asProxyProps(props);
  const deleteModalController = useOverlayController("Modal");

  return (
    <>
      <WithBoundaries.ContextMenu placement="bottom end">
        {() => {
          const cronjob = cronjobProxy.getCommon().use();
          return <DeleteMenuItem onAction={() => deleteModalController.open()} />;
        }}
      </WithBoundaries.ContextMenu>

      <DeleteCronjobModal
        controller={deleteModalController}
        cronjob={cronjobProxy}
      />
    </>
  );
};
```

### Alerts / Badges

- Alerts und Badges werden in ein `WithBoundaries.Fragment` verpackt

```
export const CustomerBankruptAlert: FC<Props> = (props) => (
  <WithBoundaries.Fragment>
    {() => {
      const { customerProxy, asBadge } = asProxyProps(props, ["customer"]);
      const isBankrupt = customerProxy.getDetailed().isBankrupt().use();

      if (!isBankrupt) {
        return null;
      }

      if (asBadge) {
        return <AlertBadge>...</AlertBadge>
      }

      return <Alert>...</Alert>;
    }}
  </WithBoundaries.Fragment>
);
```

### Field

```
export const AppInstallationSelectField: FC<Props> = (props) => {
  const { name, label, projectGhost } = asGhostProps(props, ["project"]);

  return (
    <WithBoundaries.FieldFragment suspenseFallbackProps={{ label }}>
      {() => {
        const appInstallations = projectGhost.appInstallations.execute().use().items;

        return (
          <Field name={name}>
            <Select isDisabled={appInstallations.length === 0}>
              <Label>{label}</Label>
              {sortedAppInstallations.map((i) => (
                <Option key={i.id} value={i.id}>
                  {i.description}
                </Option>
              ))}
            </Select>
          </Field>
        );
      }}
    </WithBoundaries.FieldFragment>
  );
};
```

---

# Weitere Empfehlungen

Ein durchdachtes Loading und Error-Boundary Konzept endet nicht bei der
technischen Umsetzung. Fehler sollten zuverlässig erfasst und an Monitoring
Systeme, Sentry oder Datadog weitergegeben werden, damit Probleme früh sichtbar
werden. Manuelle und automatisierte Tests helfen dabei, die eigenen Fallbacks
regelmäßig zu überprüfen und sicherzustellen, dass sie in allen relevanten
Situationen greifen. Ebenso wichtig ist eine klare und konsistente Formulierung
der Fehlermeldungen, damit User verstehen, was passiert und wie sie weitermachen
können. Für konkrete Hinweise zur sprachlichen Ausgestaltung bietet die
Guideline
[Writing for Errors](/02-foundations/03-content-guidelines/02-fehlermeldungen)
weitere Orientierung. So entsteht ein stabiles und nachvollziehbares Verhalten,
das sowohl die Entwicklung als auch die Nutzung der Anwendung unterstützt.

```

```
